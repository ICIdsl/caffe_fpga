#include "caffe/fpga/mm_fpga.hpp"
#include <fstream>
#include <iostream>

std::vector<cl::Device> g_devices = xcl::get_xil_devices();
cl::Device device = g_devices[0];
cl_int err;
cl::Context context(device, NULL, NULL, NULL, &err);
std::string deviceName = device.getInfo<CL_DEVICE_NAME>(&err);
std::string binaryFile = xcl::find_binary_file(deviceName, "mesh_processor");
cl::Program::Binaries bins = xcl::import_binary_file(binaryFile);
cl::Program program(context, std::vector<cl::Device>{device}, bins, NULL, &err);
cl::Kernel krnl_mesh_proc(program, "matmul", &err);

void Kernel_profiling(
    int transA,
    const float *aVecIn, 
    int transB,
    const float *bVecIn, 
    float *cVecOut, 
    int aRow, 
    int aCol, 
    int bRow,
    int bCol,
    float ABscaling,
    float Cscaling,
    double *fpga_times      
)
{
    std::cout << "Running batching simulation" << std::endl; 
    std::ofstream profiling_log; 
    profiling_log.open("/home/centos/src/project_data/caffe/huawei_proj/profile/log_sim.csv");

    // int ix = 0; 
    int m_sim[14] = {64,192,384,256,256,256,2304,256,3456,384,1728,192,1600,64};
    int n_sim[14] = {64,16,4,4,4,2304,4,3456,4,1728,4,1600,16,363};
    int k_sim[14] = {363,1600,1728,3456,2304,4,256,4,256,4,384,16,192,64};
        
    caffe::Timer tiling; 

    for(unsigned ix=0; ix<14; ix++)
    {
        std::cout << ix << std::endl; 
        int batch_size = 128;
        int a_size = m_sim[ix] * k_sim[ix] * batch_size; 
        int b_size = n_sim[ix] * k_sim[ix] * batch_size; 

        // std::cout << m_sim[ix] << std::endl; 
        // std::cout << n_sim[ix] << std::endl; 
        // std::cout << k_sim[ix] << std::endl; 
        std::cout << a_size << std::endl; 
        std::cout << b_size << std::endl; 
        
        float *aVecSim = new float[a_size];
        float *bVecSim = new float[b_size];
        //  int *aVecSim = new int[a_size];
        //  int *bVecSim = new int[b_size];
    
        profiling_log << TILE_ROW << "," << TILE_COL << "," << TILE_COMMON << "," << m_sim[ix] << "," << n_sim[ix] << "," << k_sim[ix]*batch_size << "," << "NULL," ;  
        
        // int tmp; 
        float tmp; 
        for (int i=0; i<a_size; i++)
        {
            tmp = (rand() / (float)RAND_MAX * 20) + -10;    
            aVecSim[i] = tmp; 
        }
        for (int i=0; i<b_size; i++)
        {
            tmp = (rand() / (float)RAND_MAX * 20) + -10;    
            bVecSim[i] = tmp; 
        }
        
        double tilingTime = 0.0; 
        tiling.Start(); 
    
        std::vector<float, aligned_allocator<float> > aVec; 
        // std::vector<int, aligned_allocator<int> > aVec; 
        int aParams[2]; 
	    TransformToFlattenTiledLayout(
            aVecSim, 
            aVec, 
            aParams,
            m_sim[ix], 
            k_sim[ix]*batch_size, 
            TILE_ROW, 
            TILE_COMMON,
            false, 
            transA
        );
        delete []aVecSim; 
        
        std::vector<float, aligned_allocator<float> > bVec;
        // std::vector<int, aligned_allocator<int> > bVec;
        int bParams[2]; 
	    TransformToFlattenTiledLayout(
            bVecSim, 
            bVec, 
            bParams,
            k_sim[ix] * batch_size, 
            n_sim[ix], 
            TILE_COMMON,
            TILE_COL,
            true, 
            transB
        );
        std::cout << bVecSim[0] << std::endl; 
        delete []bVecSim; 
        
        std::vector<float, aligned_allocator<float> > cVec;
        // std::vector<int, aligned_allocator<int> > cVec;
        for (int i=0; i<m_sim[ix] * n_sim[ix]; i++)
        {
            cVec.push_back(0); 
        }

        std::vector<int, aligned_allocator<int> > params(4); 
        params[0] = aParams[0]; 
        params[1] = bParams[0]; 
        params[2] = aParams[1]; 
        params[3] = 0; 

        tilingTime += tiling.MicroSeconds(); 
        
        #ifdef DEBUG
        std::cout << "Debugging on" << std::endl; 
        std::vector<float> cVecTmp; 
        for (int i=0; i<cRow; i++)
        {
            for (int j=0; j<cCol; j++)
            {
                cVecTmp.push_back(0); 
            }
        }
        for (int tile1 = 0; tile1 < params[0]; tile1++)
        {
            for (int tile2 = 0; tile2 < params[1]; tile2++)
            {
                int cTile = tile1 * params[1] + tile2; 

                for (int tile3 = 0; tile3 < params[2]; tile3++)
                {
                    int aTile = tile1 * params[2] + tile3; 
                    int bTile = tile2 * params[2] + tile3; 

                    for (int i=0; i<TILE_ROW; i++)
                    {
                        for (int j=0; j<TILE_COL; j++)
                        {
                            for (int k=0; k<TILE_COMMON; k++)
                            {
                                cVecTmp.at(cTile * TILE_ROW * TILE_COL + i*TILE_COL + j) += aVec.at(aTile * TILE_ROW * TILE_COMMON + i*TILE_COMMON + k) * bVec.at(bTile * TILE_COL * TILE_COMMON + k*TILE_COL + j);
                            }
                        }
                    }
                }
            }
        }
        #endif
        
	    OCL_CHECK(err, cl::CommandQueue q(context, device, CL_QUEUE_PROFILING_ENABLE | CL_QUEUE_OUT_OF_ORDER_EXEC_MODE_ENABLE, &err));

        cl::Event aWrite, bWrite, paramWrite, cWrite, kernelExec, c_read; 
        
        OCL_CHECK(err, cl::Buffer aVecLoco(context, CL_MEM_READ_ONLY | CL_MEM_USE_HOST_PTR, sizeof(float)*aVec.size(), aVec.data(), &err));
        OCL_CHECK(err, cl::Buffer bVecLoco(context, CL_MEM_READ_ONLY | CL_MEM_USE_HOST_PTR, sizeof(float)*bVec.size(), bVec.data(), &err));
        OCL_CHECK(err, cl::Buffer paramsLoco(context, CL_MEM_READ_ONLY | CL_MEM_USE_HOST_PTR, sizeof(int)*params.size(), params.data(), &err));
        OCL_CHECK(err, cl::Buffer cVecLoco(context, CL_MEM_USE_HOST_PTR, sizeof(float)*cVec.size(), cVec.data(), &err));
                    
        OCL_CHECK(err, err = q.enqueueMigrateMemObjects({aVecLoco}, 0, NULL, &aWrite)); 
        OCL_CHECK(err, err = q.enqueueMigrateMemObjects({bVecLoco}, 0, NULL, &bWrite)); 
        OCL_CHECK(err, err = q.enqueueMigrateMemObjects({paramsLoco}, 0, NULL, &paramWrite)); 
        OCL_CHECK(err, err = q.enqueueMigrateMemObjects({cVecLoco}, 0, NULL, &cWrite)); 
        
	    OCL_CHECK(err, err = krnl_mesh_proc.setArg(0, aVecLoco));
        OCL_CHECK(err, err = krnl_mesh_proc.setArg(1, bVecLoco));
        OCL_CHECK(err, err = krnl_mesh_proc.setArg(2, paramsLoco));
	    OCL_CHECK(err, err = krnl_mesh_proc.setArg(3, cVecLoco));
        
        std::vector<cl::Event> kernel_wait_events = {aWrite, bWrite, paramWrite, cWrite}; 
	    OCL_CHECK(err, err = q.enqueueTask(krnl_mesh_proc, &kernel_wait_events, &kernelExec));
        
        std::vector<cl::Event> read_wait_events = {kernelExec}; 
        OCL_CHECK(err, err = q.enqueueMigrateMemObjects({cVecLoco}, CL_MIGRATE_MEM_OBJECT_HOST, &read_wait_events, &c_read)); 
	    
        q.finish(); 
        
        cl::Event transfer_events[6]; 
        transfer_events[0] = aWrite; 
        transfer_events[1] = bWrite; 
        transfer_events[2] = cWrite; 
        transfer_events[3] = paramWrite; 
        transfer_events[4] = kernelExec; 
        transfer_events[5] = c_read; 

        cl_ulong time_start, time_end; 
        std::vector<cl_ulong> event_times; 
        for (unsigned i=0; i<6; i++)
        {
	        OCL_CHECK(err, err = transfer_events[i].wait());
	        OCL_CHECK(err, err = transfer_events[i].getProfilingInfo<cl_ulong>(CL_PROFILING_COMMAND_START, &time_start));
            OCL_CHECK(err, err = transfer_events[i].getProfilingInfo<cl_ulong>(CL_PROFILING_COMMAND_END, &time_end));
            
            event_times.push_back(time_end - time_start); 
        }

        fpga_times[1] = (event_times[0] + event_times[1] + event_times[2] + event_times[3]) / 1000000.0;  
        fpga_times[2] = (event_times[4]) / 1000000.0; 
        fpga_times[3] = (event_times[5]) / 1000000.0;
        
        #ifdef DEBUG
        for (int i=0; i<aRow; i++)
        {
            for (int j=0; j<bCol; j++)
            {
                if (cVec[i*bCol + j] - cVecTmp[i*bCol + j] > 0.0001) 
                {
                    std::cout << "tiling issue?" << std::endl; 
                    std::cout << i << "," << j << std::endl; 
                    std::cout << cVec[i*bCol + j] - cVecTmp[i*bCol + j] << std::endl; 
                }
            }
        }
        #endif
        
        tiling.Start();     
        TransformToMatrixLayoutFunc(
            cVec, 
            cVecOut, 
            TILE_ROW, 
            TILE_COL, 
            m_sim[ix],
            n_sim[ix], 
            false
        );
        tilingTime += tiling.MicroSeconds(); 
        fpga_times[0] = tilingTime / 1000.0; 
        
        double total_time = 0.0; 
        for (unsigned i=0; i<4; i++)
        {
            total_time += fpga_times[i]; 
        }
        
        profiling_log << fpga_times[0] << "," << fpga_times[1] << "," << fpga_times[2] << "," << fpga_times[3] << "," << total_time << std::endl; 
        std::cout << "here 8.2" << std::endl; 
    }
    profiling_log.close(); 
}
