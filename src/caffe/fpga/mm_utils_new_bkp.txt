#include "caffe/fpga/mm_utils.hpp"

void TransformToFlattenTiledLayout_vec(
    const float *inputMat, 
    std::vector<float, aligned_allocator<float>> &tiledFlatMat, 
    int ROWS, 
    int COLS, 
    int tR, 
    int tC, 
    bool transposeTiles, 
    bool transposeMat
)
{
    int tileIter1, tileIter2, iter1, iter2, rowIdx, colIdx; 

    int iterBound1 = tR; 
    int iterBound2 = tC; 
    int *row = &iter1; 
    int *col = &iter2; 
	
    if (transposeMat)
    {
        int tmp = tR; 
        tR = tC; 
        tC = tmp; 

        row = &iter2; 
        col = &iter1; 

        transposeTiles = !transposeTiles; 
    }
    
    int rowTilesTotal = ceil((float) ROWS / (float) tR);
	int colTilesTotal = ceil((float) COLS / (float) tC);

	int flatIndex = 0;
    float val; 

    int tileBound1 = rowTilesTotal; 
    int tileBound2 = colTilesTotal; 
    int *tileRowIndex = &tileIter1; 
    int *tileColIndex = &tileIter2; 
    if (transposeTiles)
    {
        tileBound1 = colTilesTotal; 
        tileBound2 = rowTilesTotal; 

        tileRowIndex = &tileIter2; 
        tileColIndex = &tileIter1; 
    }

    for (tileIter1 = 0; tileIter1 < tileBound1; tileIter1 ++)
    {
        for (tileIter2 = 0; tileIter2 < tileBound2; tileIter2++)
        {
            for (iter1 = 0; iter1 < iterBound1; iter1++)
            {
                for (iter2 = 0; iter2 < iterBound2; iter2++)
                {
                    rowIdx = *(row) + *(tileRowIndex) * tR; 
                    colIdx = *(col) + *(tileColIndex) * tC; 
                    if (rowIdx >= ROWS || colIdx >= COLS)
                    {
                        val = 0;      
                    }
                    else 
                    {
                        val = inputMat[rowIdx*COLS + colIdx]; 
                    }
					tiledFlatMat[flatIndex] = val;
					flatIndex = flatIndex + 1;

                }
            }
        }
    }
}

void TransformToMatrixLayoutFunc_vec(
		std::vector<float, aligned_allocator<float>> &tiledFlatMat,
		float *outputMat,
		int TR,
		int TC,
        int ROWS, 
        int COLS,
        bool transposed
)
{
	int rowTilesTotal = ceil((float) ROWS / (float) TR);
	int colTilesTotal = ceil((float) COLS / (float) TC);

    int iter1, iter2, tileIter1, tileIter2, rowIdx, colIdx; 

    int iterBound1 = TR; 
    int iterBound2 = TC; 
    int *row = &iter1; 
    int *col = &iter2; 

    int tileBound1 = rowTilesTotal; 
    int tileBound2 = colTilesTotal; 
    int *tileRowIndex = &tileIter1; 
    int *tileColIndex = &tileIter2; 
    if (transposed)
    {
        tileBound1 = colTilesTotal; 
        tileBound2 = rowTilesTotal; 

        tileRowIndex = &tileIter2; 
        tileColIndex = &tileIter1; 
    }

	int flatIndex = 0;
    for (tileIter1 = 0; tileIter1 < tileBound1; tileIter1 ++)
    {
        for (tileIter2 = 0; tileIter2 < tileBound2; tileIter2 ++)
        {
            for (iter1 = 0; iter1 < iterBound1; iter1++)
            {
                for (iter2 = 0; iter2 <iterBound2; iter2++)
                {
                    rowIdx = *(row) + *(tileRowIndex) * TR; 
                    colIdx = *(col) + *(tileColIndex) * TC; 
                    if (rowIdx < ROWS && colIdx < COLS)
                    {
                        outputMat[rowIdx * COLS + colIdx] = tiledFlatMat[flatIndex]; 
                    }
                    flatIndex ++; 
                }
            }
        }
    }
}
