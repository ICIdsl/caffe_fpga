#include "caffe/fpga/mm_fpga.hpp"

// namespace caffe {

void Kernel(
      int transA,
      const float *aVecIn, 
      int transB,
      const float *bVecIn, 
      float *cVec, 
      int aRow, 
      int aCol, 
      int bRow,
      int bCol,
      float ABscaling,
      float Cscaling//,
      // std::vector<AsyncProfiler*> &profilers
      )
{
    std::vector<AsyncProfiler*> profilers;
    int rows_wt = ceil((float) aRow / (float) TILE_ROW) * TILE_ROW; 
    int cols_wt = ceil((float) aCol / (float) TILE_COMMON) * TILE_COMMON; 
	std::cout << "Transforming weights matrix to tiled vector ..." << std::endl;
	std::vector<float, aligned_allocator<float>> aVec(rows_wt * cols_wt);
	// TransformToFlattenTiledLayout_vec<float, TILE_ROW, TILE_COMMON, false>(aVecIn, aVec, aRow, aCol);
	// TransformToFlattenTiledLayout_vec<TILE_ROW, TILE_COMMON, false>(aVecIn, aVec, aRow, aCol);

	// transform to flatten tiled vector
	std::cout << "Transforming IFM matrix to tiled vector ..." << std::endl;
    int rows_ifmT = ceil((float) bRow / (float) TILE_COMMON) * TILE_COMMON; 
    int cols_ifmT= ceil((float) bCol / (float) TILE_COL) * TILE_COL; 
	std::vector<float, aligned_allocator<float>> bVec(rows_ifmT * cols_ifmT);
	// TransformToFlattenTiledLayout_vec<float, TILE_COMMON, TILE_COL, true>(bVecIn, bVec, bRow, bCol);
	// TransformToFlattenTiledLayout_vec<TILE_COMMON, TILE_COL, true>(bVecIn, bVec, bRow, bCol);

	std::cout << "Setting up interface." << std::endl;
	std::vector<cl::Device> devices = xcl::get_xil_devices();
	cl::Device device = devices[0];

	cl_int err;
	OCL_CHECK(err, cl::Context context(device, NULL, NULL, NULL, &err));
	OCL_CHECK(err, cl::CommandQueue q(context, device, CL_QUEUE_PROFILING_ENABLE | CL_QUEUE_OUT_OF_ORDER_EXEC_MODE_ENABLE, &err));
	OCL_CHECK(err, std::string deviceName = device.getInfo<CL_DEVICE_NAME>(&err));

	std::string binaryFile = xcl::find_binary_file(deviceName, "mesh_processor");
	cl::Program::Binaries bins = xcl::import_binary_file(binaryFile);
	devices.resize(1);
	OCL_CHECK(err, cl::Program program(context, devices, bins, NULL, &err));
	OCL_CHECK(err, cl::Kernel krnl_mesh_proc(program, "mesh_processor", &err));

	std::cout << "Interface set up done." << std::endl;

	std::cout << "Block matrix multiplication ..." << std::endl;
	
    caffe::Timer fpgaFwdTimer;
	double fpgaFwdTime = 0.0;

    AsyncProfiler *ifmWrite = new AsyncProfiler(); 
    AsyncProfiler *ofmRead = new AsyncProfiler(); 
    AsyncProfiler *weightsWrite = new AsyncProfiler(); 
    AsyncProfiler *matMul = new AsyncProfiler(); 
    profilers.push_back(ifmWrite);
    profilers.push_back(ofmRead);
    profilers.push_back(weightsWrite);
    profilers.push_back(matMul);
	
    std::vector<cl::Memory*> bVecLoco(2), cVecLoco(2), aVecLoco(1); 
	std::vector<cl::Event> ofmReadEvents(2), kernel_events(2); 

	// aVecLoco[0] = new cl::Buffer(context, CL_MEM_READ_ONLY | CL_MEM_USE_HOST_PTR, sizeof(float)*TILE_ROW*A_COL, aVec.data(), &err);
	aVecLoco[0] = new cl::Buffer(context, CL_MEM_READ_ONLY | CL_MEM_USE_HOST_PTR, sizeof(float)*TILE_ROW*TILE_COMMON, aVec.data(), &err);
	std::vector<cl::Memory> weightsToMigrate = {*aVecLoco[0]}; 
	OCL_CHECK(err, err = q.enqueueMigrateMemObjects(weightsToMigrate, 0, NULL, weightsWrite->add_event())); 

	fpgaFwdTimer.Start();
    for (int tileComIdx = 0; tileComIdx < aCol; tileComIdx += TILE_COMMON)
    {
	    int iterIdx = 0;
	    for (int tileOutRowIdx = 0, rowIdx = 0; tileOutRowIdx < aRow; tileOutRowIdx += TILE_ROW)
	    {
	    	int minIdx = (rowIdx == 0) ? 2 : 0; 
	    	// must enter with one of the buffers filled with 0 
	    	for (int tileOutColIdx = 0, colIdx = 0; tileOutColIdx < bCol; tileOutColIdx += TILE_COL)
	    	{
	    		int buffer_num = (colIdx % 2); 
	    		
	    		if (colIdx >= minIdx)
	    		{	
	    			delete bVecLoco[buffer_num]; 
	    			delete cVecLoco[buffer_num]; 
	    		}
	    		
	    		cVecLoco[buffer_num] = new cl::Buffer(context, CL_MEM_WRITE_ONLY | CL_MEM_USE_HOST_PTR, sizeof(c_t)*TILE_ROW*TILE_COL, cVec+iterIdx*TILE_ROW*TILE_COL, &err); 
	    		
	    		// bVecLoco[buffer_num] = new cl::Buffer(context, CL_MEM_READ_ONLY | CL_MEM_USE_HOST_PTR, sizeof(float)*A_COL*TILE_COL, bVec.data()+colIdx*A_COL*TILE_COL, &err);
	    		bVecLoco[buffer_num] = new cl::Buffer(context, CL_MEM_READ_ONLY | CL_MEM_USE_HOST_PTR, sizeof(float)*TILE_COMMON*TILE_COL, bVec.data() + tileComIdx*TILE_COL + colIdx*bRow*TILE_COL, &err); 
                std::vector<cl::Memory> bufferWrite = {*bVecLoco[buffer_num]};
	    		OCL_CHECK(err, err = q.enqueueMigrateMemObjects(bufferWrite, 0, NULL, ifmWrite->add_event())); 
	    	
	    		OCL_CHECK(err, err = krnl_mesh_proc.setArg(0, *(aVecLoco[0])));
	    		OCL_CHECK(err, err = krnl_mesh_proc.setArg(1, *(bVecLoco[buffer_num])));
	    		OCL_CHECK(err, err = krnl_mesh_proc.setArg(2, *(cVecLoco[buffer_num])));
	    		OCL_CHECK(err, err = krnl_mesh_proc.setArg(3, 5));
	    		OCL_CHECK(err, err = krnl_mesh_proc.setArg(4, TILE_ROW));
	    		OCL_CHECK(err, err = krnl_mesh_proc.setArg(5, TILE_COMMON));
	    		OCL_CHECK(err, err = krnl_mesh_proc.setArg(6, TILE_COL));
	    		OCL_CHECK(err, err = krnl_mesh_proc.setArg(7, 0));

	    		std::vector<cl::Event> matMulDepList = {ifmWrite->get_last_event(), weightsWrite->get_last_event()}; 
	    		OCL_CHECK(err, err = q.enqueueTask(krnl_mesh_proc, &matMulDepList, matMul->add_event()));
	    		
	    		std::vector<cl::Memory> bufferRead = {*cVecLoco[buffer_num]};
	    		std::vector<cl::Event> readDepList = {matMul->get_last_event()}; 
	    		OCL_CHECK(err, err = q.enqueueMigrateMemObjects(bufferRead, CL_MIGRATE_MEM_OBJECT_HOST, &readDepList, ofmRead->add_event())); 
	    		ofmReadEvents[buffer_num] = ofmRead->get_last_event(); 
	    
	    		// move to next tile of ofm matrix 
	    		colIdx++;
	    		iterIdx++;
	    	}

	    	rowIdx++;
	    	
	    	delete aVecLoco[0]; 
	    	// aVecLoco[0] = new cl::Buffer(context, CL_MEM_READ_ONLY | CL_MEM_USE_HOST_PTR, sizeof(float)*TILE_ROW*A_COL, aVec.data()+rowIdx*TILE_ROW*A_COL, &err);
	    	aVecLoco[0] = new cl::Buffer(context, CL_MEM_READ_ONLY | CL_MEM_USE_HOST_PTR, sizeof(float)*TILE_ROW*TILE_COMMON, aVec.data() + tileComIdx*TILE_ROW + rowIdx*TILE_ROW*aCol, &err);
	    	std::vector<cl::Memory> weightsToMigrate = {*aVecLoco[0]}; 
	    	std::vector<cl::Event> weightsDepList = {matMul->get_last_event()}; 
	    	OCL_CHECK(err, err = q.enqueueMigrateMemObjects(weightsToMigrate, 0, &weightsDepList, weightsWrite->add_event())); 
	    }
    }
	fpgaFwdTime += fpgaFwdTimer.MicroSeconds();

	ifmWrite->calculate_times();
	weightsWrite->calculate_times();
	ofmRead->calculate_times(); 
	matMul->calculate_times(); 
    
    // return fpgaFwdTime; 
}

// }
