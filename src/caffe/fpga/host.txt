#include "mesh_processor.hpp"
#include "utils.hpp"
#include "xcl2.hpp"
#include <vector>
#define DATA_SIZE 4096
#include <unistd.h>

template <typename Dtype>
void im2col_cpu(const Dtype* data_im, const int channels,
    const int height, const int width, const int kernel_h, const int kernel_w,
    const int pad_h, const int pad_w,
    const int stride_h, const int stride_w,
    const int dilation_h, const int dilation_w,
    Dtype* data_col
);

int main(int argc, char** argv)
{
	std::cout << "Staring layer-centric testing of DL traning IP ..." << std::endl;

	std::cout << "Loading input feature maps and weights in matrices A and B ..." << std::endl;
	std::ifstream ifmFile("../../test_data/ifm_layer1_raw.txt");
	float inputElement;
	std::vector<b_t> inputElements;
	int i = 0;
	while (ifmFile >> inputElement)
	{
		inputElements.push_back(inputElement);
        i++;
	}
	ifmFile.close();
	std::cout << "Input elements total = " << inputElements.size() << std::endl;

	static b_t inputElements_[3*224*224];
	for (int elementIdx = 0; elementIdx < inputElements.size(); elementIdx++)
	{
		inputElements_[elementIdx] = inputElements[elementIdx];
	}
    
	static b_t ifmMat[B_ROW*B_COL];
	im2col_cpu<b_t>(inputElements_, 3,
				224, 224, 7, 7,
				3, 3,
				2, 2,
				1, 1,
				ifmMat
				);
    
	// populate weights matrix B
	std::ifstream weightsFile("../../test_data/weights_layer1_raw.txt");
	float weight;
	std::vector<a_t> weights;
	while (weightsFile >> weight)
	{
		weights.push_back(weight);
	}
	weightsFile.close();
    
    static a_t weightsMat[A_ROW*A_COL];
	for (int weightIdx = 0; weightIdx < weights.size(); weightIdx++)
	{
		weightsMat[weightIdx] = weights[weightIdx];
	}

	std::cout << "Weights total = " << weights.size() << std::endl;

    static c_t expOp[A_ROW * B_COL]; 
    for(int i=0; i<A_ROW; i++)
    {
        for (int j=0; j<B_COL; j++)
        {
            for (int k=0; k<A_COL; k++)
            {
                expOp[i*B_COL + j] += weightsMat[i*A_COL + k] * ifmMat[k*B_COL + j]; 
            }
        }
    }
    
    std::ofstream matMulFile("../../test_data/tmpOp.txt"); 
    for (int i=0; i<C_ROW; i++)
    {
        for (int j=0; j<C_COL; j++)
        {
           matMulFile << expOp[i*C_COL + j] << " "; 
        }
        matMulFile << std::endl; 
    }

	std::vector<c_t, aligned_allocator<c_t>> tileVec(TILE_ROW*TILE_COMMON);
	for (int i = 0; i < TILE_ROW*TILE_COMMON; i++)
	{
		tileVec[i] = 0;
	}

	// load biases
	std::ifstream biasFile("../../test_data/bias_layer1_raw.txt");
	float bias;
	std::vector<c_t> biases;
	while (biasFile >> bias)
	{
		biases.push_back(bias);
	}
	biasFile.close();
	std::cout << "Biases total = " << biases.size() << std::endl;
    
    int tileNum = 3;

	// transform to flatten tiled vector
	std::cout << "Transforming weights matrix to tiled vector ..." << std::endl;
	std::vector<a_t, aligned_allocator<a_t>> weightsVec;
    static int weightsParams[2]; 
	TransformToFlattenTiledLayout(
        weightsMat, 
        weightsVec, 
        weightsParams,
        A_ROW, 
        A_COL, 
        TILE_ROW, 
        TILE_COMMON, 
        false, 
        0
    );
    weightsParams[0] = 2; 
    weightsParams[1] = tileNum; 
    // weightsParams[0] = 0; 
    // weightsParams[1] = 0; 
    
    // transform to flatten tiled vector
	std::cout << "Transforming IFM matrix to tiled vector ..." << std::endl;
	std::vector<b_t, aligned_allocator<b_t>> ifmVec;
    static int ifmParams[2]; 
	TransformToFlattenTiledLayout(
        ifmMat, 
        ifmVec,
        ifmParams,
        B_ROW, 
        B_COL, 
        TILE_COMMON, 
        TILE_COL, 
        true, 
        0
    );
    ifmParams[0] = tileNum; 
    ifmParams[1] = 2; 
    // ifmParams[0] = 0; 
    // ifmParams[1] = 0; 
    
    std::ofstream tmpFileW("../../test_data/tmpW.txt");
    int flatIdx = 0; 
    for (int k=0; k<tileNum; k++)
    {
	    for (int i=0; i<TILE_ROW; i++)
	    {
	    	for (int j=0; j<TILE_COMMON; j++)
	    	{
	    		tmpFileW << weightsVec[flatIdx] << " ";
                flatIdx ++; 
	    	}
	    	tmpFileW << std::endl;
	    }
        tmpFileW << std::endl; 
    }

    std::ofstream tmpFileIFM("../../test_data/tmpIFM.txt");
    flatIdx = 0;
    for (int k=0; k<tileNum; k++)
    {
	    for (int i=0; i<TILE_COMMON; i++)
	    {
	    	for (int j=0; j<TILE_COL; j++)
	    	{
	    		tmpFileIFM << ifmVec[flatIdx] << " ";
                flatIdx++; 
	    	}
	    	tmpFileIFM << std::endl;
	    }
    }
    
	std::vector<c_t, aligned_allocator<c_t>> ofmExp(C_ROW * C_COL);
    int aTile, bTile, cTile; 
    for (int tile1 = 0; tile1 < weightsParams[0]; tile1 ++)
    {
        bTile = 0; 
        for (int tile2 = 0; tile2 < ifmParams[0]; tile2 ++)
        {
            aTile = tile1*weightsParams[1];  
            for (int t = 0; t < weightsParams[1]; t ++)
            {
                for (int i=0; i<TILE_ROW; i++)
                {
                    for (int j=0; j<TILE_COL; j++)
                    {
                        for (int k=0; k<TILE_COMMON; k++)
                        {
                            cTile = tile1*ifmParams[0] + tile2; 
                            ofmExp[cTile*TILE_ROW*TILE_COL + i*TILE_COL + j] += weightsVec[aTile*TILE_ROW*TILE_COMMON + i*TILE_COMMON + k] * ifmVec[bTile*TILE_COL*TILE_COMMON + k*TILE_COL + j];  
                        }
                    }
                }
                aTile ++; 
                bTile ++; 
            }
        }
    }
    
    static c_t ofmMat[C_ROW * C_COL]; 
    TransformToMatrixLayoutFunc(
        ofmExp, 
        ofmMat, 
        TILE_ROW, 
        TILE_COL, 
        A_ROW, 
        B_COL, 
        false
    );
    
    std::ofstream tmpFileOFM("../../test_data/tmpOFM.txt"); 
    for (int i=0; i<C_ROW; i++)
    {
        for (int j=0; j<C_COL; j++)
        {
            tmpFileOFM << ofmMat[i*C_COL + j] << " " ; 
        }
        tmpFileOFM << std::endl; 
    }

	std::vector<c_t, aligned_allocator<c_t>> ofmMatTmp(C_ROW * C_COL);
    for (int i=0; i<C_ROW; i++)
    {
        for (int j=0; j<C_COL; j++)
        {
            ofmMatTmp[i*C_COL + j] = 0; 
        }
    }

    static int params[3]; 
    params[0] = weightsParams[0]; 
    params[1] = ifmParams[0]; 
    params[2] = weightsParams[1]; 

	std::cout << "Setting up interface." << std::endl;
	std::vector<cl::Device> devices = xcl::get_xil_devices();
	cl::Device device = devices[0];

	cl_int err;
	OCL_CHECK(err, cl::Context context(device, NULL, NULL, NULL, &err));
	OCL_CHECK(err, cl::CommandQueue q(context, device, CL_QUEUE_PROFILING_ENABLE, &err));
	OCL_CHECK(err, std::string deviceName = device.getInfo<CL_DEVICE_NAME>(&err));

	std::string binaryFile = xcl::find_binary_file(deviceName, "matmul");
	cl::Program::Binaries bins = xcl::import_binary_file(binaryFile);
	devices.resize(1);
	OCL_CHECK(err, cl::Program program(context, devices, bins, NULL, &err));
	OCL_CHECK(err, cl::Kernel krnl_mesh_proc(program, "matmul", &err));

	std::cout << "Interface set up done." << std::endl;

	OCL_CHECK(err, cl::Buffer weightsVecLoco(context, CL_MEM_READ_ONLY, sizeof(a_t)*weightsVec.size(), NULL, &err));
	OCL_CHECK(err, cl::Buffer ifmVecLoco(context, CL_MEM_READ_ONLY, sizeof(b_t)*ifmVec.size(), NULL, &err));
	OCL_CHECK(err, cl::Buffer paramsLoco(context, CL_MEM_READ_ONLY, sizeof(int)*3, NULL, &err));
	OCL_CHECK(err, cl::Buffer ofmVecLoco(context, CL_MEM_READ_WRITE, sizeof(c_t)*C_ROW*C_COL, NULL, &err));

    std::cout << "Performing Tiling on FPGA ..." << std::endl;
	
	OCL_CHECK(err, err = clEnqueueWriteBuffer(q(), weightsVecLoco(), CL_TRUE, 0, sizeof(a_t)*weightsVec.size(), weightsVec.data(), 0, NULL, NULL));
	OCL_CHECK(err, err = clEnqueueWriteBuffer(q(), ifmVecLoco(), CL_TRUE, 0, sizeof(b_t)*ifmVec.size(), ifmVec.data(), 0, NULL, NULL));
	OCL_CHECK(err, err = clEnqueueWriteBuffer(q(), paramsLoco(), CL_TRUE, 0, sizeof(int)*3, params, 0, NULL, NULL));
	OCL_CHECK(err, err = clEnqueueWriteBuffer(q(), ofmVecLoco(), CL_TRUE, 0, sizeof(c_t)*C_ROW*C_COL, ofmMatTmp.data(), 0, NULL, NULL));

	OCL_CHECK(err, err = krnl_mesh_proc.setArg(0, weightsVecLoco));
    OCL_CHECK(err, err = krnl_mesh_proc.setArg(1, ifmVecLoco));
    OCL_CHECK(err, err = krnl_mesh_proc.setArg(2, paramsLoco));
	OCL_CHECK(err, err = krnl_mesh_proc.setArg(3, ofmVecLoco));

	OCL_CHECK(err, err = q.enqueueTask(krnl_mesh_proc));

    OCL_CHECK(err, err = clEnqueueReadBuffer(q(), ofmVecLoco(), CL_TRUE, 0, sizeof(c_t)*C_ROW*C_COL, ofmMatTmp.data(), 0, NULL, NULL));
    q.finish();

    std::cout << "Tiling Finished ..." << std::endl;
    
    static c_t ofmUntiled[C_ROW * C_COL]; 
    TransformToMatrixLayoutFunc(
        ofmMatTmp, 
        ofmUntiled, 
        TILE_ROW, 
        TILE_COL, 
        A_ROW, 
        B_COL, 
        false
    );

    std::ofstream tmpFileTile("../../test_data/tmpTile.txt");
    for(int i=0; i<C_ROW; i++)
    {
        for (int j=0; j<C_COL; j++)
        {
            tmpFileTile << ofmUntiled[i*C_COL + j] << " "; 
        }
        tmpFileTile << std::endl; 
    }
	
    std::cout << "App finished!" << std::endl << std::endl;

    return 0;
}

template <typename Dtype>
void im2col_cpu(const Dtype* data_im, const int channels,
    const int height, const int width, const int kernel_h, const int kernel_w,
    const int pad_h, const int pad_w,
    const int stride_h, const int stride_w,
    const int dilation_h, const int dilation_w,
    Dtype* data_col
	)
{
	const int output_h = (height + 2 * pad_h -
						 (dilation_h * (kernel_h - 1) + 1)) / stride_h + 1;
	const int output_w = (width + 2 * pad_w -
						 (dilation_w * (kernel_w - 1) + 1)) / stride_w + 1;
	const int channel_size = height * width;
	for (int channel = channels; channel--; data_im += channel_size)
	{
		for (int kernel_row = 0; kernel_row < kernel_h; kernel_row++)
		{
			for (int kernel_col = 0; kernel_col < kernel_w; kernel_col++)
			{
				int input_row = -pad_h + kernel_row * dilation_h;
				for (int output_rows = output_h; output_rows; output_rows--)
				{
					if (!is_a_ge_zero_and_a_lt_b(input_row, height))
					{
						for (int output_cols = output_w; output_cols; output_cols--)
						{
							*(data_col++) = 0;
						}
					}
					else
					{
						int input_col = -pad_w + kernel_col * dilation_w;
						for (int output_col = output_w; output_col; output_col--)
						{
							if (is_a_ge_zero_and_a_lt_b(input_col, width))
							{
								*(data_col++) = data_im[input_row * width + input_col];
							}
							else
							{
								*(data_col++) = 0;
							}
							input_col += stride_w;
						}
					}
					input_row += stride_h;
				}
			}
		}
	}
}

