#include "caffe/fpga/mm_fpga.hpp"

void Kernel(
      int transA,
      const float *aVecIn, 
      int transB,
      const float *bVecIn, 
      float *cVecOut, 
      int aRow, 
      int aCol, 
      int bRow,
      int bCol,
      float ABscaling,
      float Cscaling//,
      // std::vector<AsyncProfiler*> &profilers
      )
{
    std::vector<std::vector<AsyncProfiler*> > profilers;
    
	std::cout << "Transforming weights matrix to tiled vector ..." << std::endl;
    int rowsATiled, colsATiled; 
    if (transA)
    {
        rowsATiled = ceil((float) aCol / (float) TILE_ROW) * TILE_ROW; 
        colsATiled = ceil((float) aRow / (float) TILE_COMMON) * TILE_COMMON; 
    }
    else
    {
        rowsATiled = ceil((float) aRow / (float) TILE_ROW) * TILE_ROW; 
        colsATiled = ceil((float) aCol / (float) TILE_COMMON) * TILE_COMMON; 
    }
	std::vector<float, aligned_allocator<float>> aVec(rowsATiled * colsATiled);
    TransformToFlattenTiledLayout_vec(
        aVecIn, 
        aVec, 
        aRow, 
        aCol, 
        TILE_ROW, 
        TILE_COMMON,
        false, 
        transA
    );

	// transform to flatten tiled vector
	std::cout << "Transforming IFM matrix to tiled vector ..." << std::endl;
    int rowsBTiled, colsBTiled; 
    if (transB)
    {
        rowsBTiled = ceil((float) bCol / (float) TILE_COMMON) * TILE_ROW; 
        colsBTiled = ceil((float) bRow / (float) TILE_COL) * TILE_COMMON; 
    }
    else
    {
        rowsBTiled = ceil((float) bRow / (float) TILE_COMMON) * TILE_ROW; 
        colsBTiled = ceil((float) bCol / (float) TILE_COL) * TILE_COMMON; 
    }
	std::vector<float, aligned_allocator<float>> bVec(rowsBTiled * colsBTiled);
    TransformToFlattenTiledLayout_vec(
        bVecIn, 
        bVec, 
        bRow, 
        bCol, 
        TILE_COMMON,
        TILE_COL,
        true, 
        transA
    );

    int cRow = aRow; 
    int cCol = bCol; 
    std::vector<float, aligned_allocator<float>> cVec(cRow * cCol); 
    for (int i=0; i<cVec.size(); i++)
    {
        cVec[i] = 0; 
    }

	std::cout << "Setting up interface." << std::endl;
	std::vector<cl::Device> devices = xcl::get_xil_devices();
	cl::Device device = devices[0];

	cl_int err;
	OCL_CHECK(err, cl::Context context(device, NULL, NULL, NULL, &err));
	OCL_CHECK(err, cl::CommandQueue q(context, device, CL_QUEUE_PROFILING_ENABLE | CL_QUEUE_OUT_OF_ORDER_EXEC_MODE_ENABLE, &err));
	OCL_CHECK(err, std::string deviceName = device.getInfo<CL_DEVICE_NAME>(&err));

	std::string binaryFile = xcl::find_binary_file(deviceName, "mesh_processor");
	cl::Program::Binaries bins = xcl::import_binary_file(binaryFile);
	devices.resize(1);
	OCL_CHECK(err, cl::Program program(context, devices, bins, NULL, &err));
	OCL_CHECK(err, cl::Kernel krnl_mesh_proc(program, "mesh_processor", &err));

	std::cout << "Interface set up done." << std::endl;

	std::cout << "Block matrix multiplication ..." << std::endl;
	
    caffe::Timer fpgaFwdTimer;
	double fpgaFwdTime = 0.0;
    
    std::vector<AsyncProfiler *> ifmWriteVec = {new AsyncProfiler(), new AsyncProfiler()}; 
    std::vector<AsyncProfiler *> ofmReadVec = {new AsyncProfiler(), new AsyncProfiler()}; 
    std::vector<AsyncProfiler *> ofmWriteVec = {new AsyncProfiler(), new AsyncProfiler()}; 
    std::vector<AsyncProfiler *> weightsWriteVec = {new AsyncProfiler()}; 
    std::vector<AsyncProfiler *> matMulVec = {new AsyncProfiler(), new AsyncProfiler()}; 
    profilers.push_back(ifmWriteVec);
    profilers.push_back(ofmReadVec);
    profilers.push_back(weightsWriteVec);
    profilers.push_back(matMulVec);
    profilers.push_back(ofmWriteVec);
    
    AsyncProfiler *weightsWrite, *ifmWrite, *ofmRead, *ofmWrite, *matMul; 
    weightsWrite = weightsWriteVec[0]; 
	
    std::vector<cl::Memory*> bVecLoco(2), cVecLoco(2), aVecLoco(1); 
	std::vector<cl::Event> ofmReadEvents(2), kernel_events(2); 

	aVecLoco[0] = new cl::Buffer(context, CL_MEM_READ_ONLY | CL_MEM_USE_HOST_PTR, sizeof(float)*TILE_ROW*TILE_COMMON, aVec.data(), &err);
	std::vector<cl::Memory> weightsToMigrate = {*aVecLoco[0]}; 
	OCL_CHECK(err, err = q.enqueueMigrateMemObjects(weightsToMigrate, 0, NULL, weightsWrite->add_event())); 

	fpgaFwdTimer.Start();
    for (int tileComIdx = 0; tileComIdx < aCol; tileComIdx += TILE_COMMON)
    {
	    int iterIdx = 0;
	    for (int tileOutRowIdx = 0, rowIdx = 0; tileOutRowIdx < aRow; tileOutRowIdx += TILE_ROW)
	    {
	    	aVecLoco[0] = new cl::Buffer(context, CL_MEM_READ_ONLY | CL_MEM_USE_HOST_PTR, sizeof(float)*TILE_ROW*TILE_COMMON, aVec.data() + tileComIdx*TILE_ROW + rowIdx*TILE_ROW*aCol, &err);
	    	std::vector<cl::Memory> weightsToMigrate = {*aVecLoco[0]}; 
            if (tileComIdx == 0 && iterIdx == 0)
            {
	    	    OCL_CHECK(err, err = q.enqueueMigrateMemObjects(weightsToMigrate, 0, NULL, weightsWrite->add_event())); 
            }
            else
            {
	    	    std::vector<cl::Event> weightsDepList = {matMul->get_last_event()}; 
	    	    OCL_CHECK(err, err = q.enqueueMigrateMemObjects(weightsToMigrate, 0, &weightsDepList, weightsWrite->add_event())); 
            }
	    	
            for (int tileOutColIdx = 0, colIdx = 0; tileOutColIdx < bCol; tileOutColIdx += TILE_COL)
	    	{
	            int minIdx = (tileComIdx == 0 && iterIdx == 0) ? 2 : 0; 
	    		int buffer_num = (colIdx % 2); 
	    		
	    		if (colIdx >= minIdx)
	    		{	
	    			delete bVecLoco[buffer_num]; 
	    			delete cVecLoco[buffer_num]; 
	    		}

                ifmWrite = ifmWriteVec[buffer_num]; 
                ofmWrite = ofmWriteVec[buffer_num];
                matMul = matMulVec[buffer_num]; 
                ofmRead = ofmReadVec[buffer_num]; 
	    		
	    		cVecLoco[buffer_num] = new cl::Buffer(context, CL_MEM_WRITE_ONLY | CL_MEM_USE_HOST_PTR, sizeof(float)*TILE_ROW*TILE_COL, cVec.data()+iterIdx*TILE_ROW*TILE_COL, &err); 
	    		bVecLoco[buffer_num] = new cl::Buffer(context, CL_MEM_READ_ONLY | CL_MEM_USE_HOST_PTR, sizeof(float)*TILE_COMMON*TILE_COL, bVec.data() + tileComIdx*TILE_COL + colIdx*bRow*TILE_COL, &err); 
                std::vector<cl::Memory> bufferWrite = {*bVecLoco[buffer_num]};
	    		OCL_CHECK(err, err = q.enqueueMigrateMemObjects(bufferWrite, 0, NULL, ifmWrite->add_event())); 
	    		std::vector<cl::Memory> bufferWrite1 = {*cVecLoco[buffer_num]};
	    		OCL_CHECK(err, err = q.enqueueMigrateMemObjects(bufferWrite1, 0, NULL, ofmWrite->add_event())); 
	    	
	    		OCL_CHECK(err, err = krnl_mesh_proc.setArg(0, *(aVecLoco[0])));
	    		OCL_CHECK(err, err = krnl_mesh_proc.setArg(1, *(bVecLoco[buffer_num])));
	    		OCL_CHECK(err, err = krnl_mesh_proc.setArg(2, *(cVecLoco[buffer_num])));
	    		OCL_CHECK(err, err = krnl_mesh_proc.setArg(3, 5));
	    		OCL_CHECK(err, err = krnl_mesh_proc.setArg(4, TILE_ROW));
	    		OCL_CHECK(err, err = krnl_mesh_proc.setArg(5, TILE_COMMON));
	    		OCL_CHECK(err, err = krnl_mesh_proc.setArg(6, TILE_COL));
	    		OCL_CHECK(err, err = krnl_mesh_proc.setArg(7, 0));

	    		std::vector<cl::Event> matMulDepList = {ifmWrite->get_last_event(), weightsWrite->get_last_event(), ofmWrite->get_last_event()}; 
	    		OCL_CHECK(err, err = q.enqueueTask(krnl_mesh_proc, &matMulDepList, matMul->add_event()));
	    		
	    		std::vector<cl::Memory> bufferRead = {*cVecLoco[buffer_num]};
	    		std::vector<cl::Event> readDepList = {matMul->get_last_event()}; 
	    		OCL_CHECK(err, err = q.enqueueMigrateMemObjects(bufferRead, CL_MIGRATE_MEM_OBJECT_HOST, &readDepList, ofmRead->add_event())); 
	    
	    		// move to next tile of ofm matrix 
	    		colIdx++;
	    		iterIdx++;
	    	}

	    	rowIdx++;
	    	delete aVecLoco[0]; 
	    }
        q.flush(); 
    }
	fpgaFwdTime += fpgaFwdTimer.MicroSeconds();

	weightsWrite->calculate_times();
    for (int i=0; i<2; i++)
    {
	    ifmWriteVec[i]->calculate_times();
	    ofmReadVec[i]->calculate_times(); 
	    ofmWriteVec[i]->calculate_times(); 
	    matMulVec[i]->calculate_times(); 
    }

    TransformToMatrixLayoutFunc_vec(
        cVec, 
        cVecOut, 
        TILE_ROW, 
        TILE_COL, 
        cRow,
        cCol, 
        false
    );
    
    for (int i=0; i<profilers.size(); i++)
    {
        if (i == 2)
        {
            delete profilers[i][0]; 
        }
        else 
        {
            for (int j=0; j<2; j++)
            {
                delete profilers[i][j]; 
            }
        }
    }
}
